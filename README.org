#+COMMENT: -*- toc-org-mode: t -*-;
#+STARTUP: showall

* peut-publier                                                          :TOC:
- [[#peut-publier-enables-users-to][Peut-publier Enables Users To...]]
- [[#background][Background]]
  - [[#recipe-for-a-simple-static-site-generator][Recipe for a simple static site generator]]
  - [[#1-renderer][1. Renderer]]
  - [[#2-file-handling][2. File handling]]
  - [[#3-meta-data][3. Meta-data]]
  - [[#4-assemble][4. Assemble]]
- [[#beyond-simple][Beyond simple]]
- [[#footnotes][Footnotes]]

* Peut-publier Enables Users To...
Build a website.  Use the markup language you want, according to your
workflow.  Take control of the system and direct its behavior.  Modify
it instead of you.

=peut-publier= enables you to publish as you see fit.

* Background
** Recipe for a simple static site generator
A static website is a collection of HTML files containing links to one
another.  The HTML describes a structure for some content.  It's
tedious to write HTML by hand and the structure it provides is often
uniform.  So, it makes sense to separate the content from the
structure and use a tool to rejoin the two.  The tool is called a
static site generator.  The structure should be easy to modify and the
generator shouldn't care what the content is.

Practically speaking, a web page is composed of a head and a body.
The head has parts which never change, like a style sheet reference,
favicon, or charset definition.  Other parts, like the title, will
vary.  The content lives in the body and is sandwiched between a
preamble and a postamble.  The preamble simply comes before the
content and is often used for things like menus or banners.  The
postamble goes after the content, such as a copyright or website
information.

#+begin_example
+--<head>----------+
| static-head      |
| variable-head    |
+--<body>----------+
| body-preamble    |
| rendered-content |
| body-postamble   |
+------------------+
#+end_example

The head, preamble, and postamble are HTML.  The content is not, per
se.  To ensure an HTML body, the content will need to be
rendered/converted/transformed into HTML.  The renderer is the primary
component of a generator. It is a black box machine in which some unit
of content is passed in and an HTML representation of the content is
spit out.  Otherwise, the generator must facilitate rendering, as well
as assemble the head and body components into the individual web pages
in such a way as to form a cohesive website.

Unless you want content source to be ephemeral, the content source
should persist on disk in some fashion.  Permanent data is typically
stored in files. Further, since the content may be conceptually
distinct, different pieces of content should probably be kept
separate.  A natural separator is to use separate files for separate
content.  Therefore, it makes sense to render files.

Many files are best gathered in a single directory.  The generator
should know about this location. It should also know where to put the
final result.  Input and output directories need to be defined.

As part of the assembly process, the generator may want to make use of
meta-data.  That's all the info regarding the content, things like
creation date, title, author, content categories, etc.  It might not
be strictly necessary, but including functionality for handling
meta-data would probably be wise.  Meta-data can live in only two
places, in the content file or outside of it.  Storing the meta-data
outside the file would require associating it correctly with the
appropriate data, unless it were placed in the filename.  Since most
file systems limit filename length, require a limited character set,
and don't handle spaces well, storing meta-data in the filename is
probably a bad idea.  Storing meta-data in the file, however,
introduces a strong, natural association: the meta-data is associated
with whatever content data is also within the file.

I think that's it.

Summary:

1. Handle file input and output
   - source and destination paths
   - read and write (multiple) files
2. Handle meta-data
   - extract meta-data from source files
3. Render content
   - allow arbitrary content format
4. Assemble constituent parts

** 1. Renderer
Most static site generators work with only one or a handful of input
formats like Markdown (which flavor?), Org, or reStructuredText.  But
there's also AsciiDoc and DokuWiki and on and on.  One might handle
tables well, but then require an odd notation for titles or something.
Maybe you wrote in reStructuredText 10 years ago, although you prefer
Markdown now, and don't want to convert formats.  It's easy to write a
generator by baking in the format.

It's also easy to write a generator that doesn't care about the
format. Just have it output a string of HTML since that's what is
ultimately needed.  Leave the HTML conversion to the author of the
markup language (or to pandoc).  When written in this way, the markup
language becomes interchangeable.

The meta-data is alongside content within the file. There are two
general steps: process source (convert) and post-process (index).
These could happen at once or separately.  If happening at once,
post-processing would require processing.  Yet, it's conceivable that
you might want to post-process independently. For example, assemble an
index of pages for a new page that was created; this shouldn't require
reprocessing all other pagex.  The tasks are separate and are likely
more flexible when kept independent.

The source could be split into meta-data and content, with each part
sent its own way at that time.  But time would be a component.
Although itbmay be inefficient to access a fike multiple times, this
allows for arbitrary access to information.  The latter appears more
flexible.

There's a symmetric relationship:
- Get meta-data/strip content (meta-data parser)
- Strip meta-data/Get content (renderer)

The renderer function gets the content and acts on it, converting.
The meta-data function gets the meta-data and acts on it, parsing.

Could operate on:
- file
- string
- buffer


** 2. File handling
A post file has three parts, the name, the content, and the meta-data.
The content needs to be rendered, the meta-data parsed.  The two must
be separated.

The renderer ideally shouldn't be doing the separating.  Its job is to
convert.

- work with files
- process-send-string
- shell-command-to-string

There's not a good answer for what functions should operate on: file,
string, or buffer.

If a file is chosen, then the renderer must strip the meta-data.

Refactor peut-publier-render-to-html to strip meta data.

Have the renderer take a string (or file) and return string.

** 3. Meta-data
Meta-data is information about the content, such as the title, an
author, or a category.  There are three possible places to store
meta-data: inside the content file, encoded within the filename, or in
an external resource.  Storing meta-data alongside the content is the
best option; it is simple yet flexible.  Filenames have character and
length restrictions which make them undesirable. External storage
requires considerably more complexity, as with a database.

Meta-data stored within the file will need to be separated from the
content.  Grouping the meta-data in one location will make this
easier.  The top, as with a title or date, is a natural spot.  Putting
meta-data at the top may also facilitate parsing.

The question is then, how to actually separate meta-data from content?

The possibilities appear to be:

1. Reserve a fixed number of lines at the top
2. Delimit the meta-data section[fn:1]
3. Use a special key-value pair notation[fn:2]

Using a fixed number of lines is the least attractive option.
Although simple, it is inherently rigid and likely short-sighted.
These qualites run contrary to the intent of =peut-publier=, to adapt
easily with change. A delimited meta-data section is the counterpart
to a fixed number of lines, being essentially a variable number of
lines. It is defined by start and end delimiters; everything between
these is meta-data to be extracted.  Such a section must be identified
through searching or parsing the file. Implementing a special
key-value pair notation would also work. This might involve the use of
a special character, or characters, to indicate a key-value pair.
This too would require searching or parsing the entire file.

Another way to view the list of possibilities is:

1. Read a fixed amount off the top
2. Search/parse the file

The second option is clearly more flexible. It's possible to go wild
and parse the entire file with a custom parser and allow users to
scatter meta-data willy-nilly.  However, restricting meta-data to a
contiguous, delimited section dramatically reduces our work as
developers while also granting users more flexibility by offloading
the meta-data parsing.

1. Define start and end delimiters
2. Extract region between delimiters
3. Pass region to external parser

Let's delimit from the beginning of the file to the first blank line.








** 4. Assemble

* Beyond simple
As a package, it might be nice to include some conveniences such as:

- ability to have different page layouts
- a style sheet
- automated source file creation
- all-in-one renderer and preview option
- RSS feed

* Footnotes

[fn:1] Markdown uses three backticks (=```=); Org uses
=#+begin/#+end=; JSON uses curly-braces, etc.

[fn:2] The Org mode export facility, for example, uses a
hash-plus-colon pattern to indicate meta-data (e.g. =#+TITLE: Moby
Dick.=).  The key is the word between the hash-plus and the colon,
whereas the value is anything after the colon until the end of the
line.
